/**
 * PTV-TRMNL v5.26 - V11 Journey Dashboard
 * 
 * CRITICAL HARDWARE NOTES (TRMNL OG):
 * - FONT_8x8 ONLY: FONT_12x16 causes 90° rotation bug
 * - BROWNOUT DISABLED: ESP32-C3 needs WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0)
 * - See KNOWN-ISSUES.md and DEVELOPMENT-RULES.md for details
 *
 * Copyright (c) 2026 Angus Bergman
 * Licensed under CC BY-NC 4.0
 */

#include <Arduino.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <WiFiClientSecure.h>
#include <WiFiManager.h>
#include <Preferences.h>
#include <ArduinoJson.h>
#include <bb_epaper.h>

#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"
#include "../include/config.h"

#define SCREEN_W 800
#define SCREEN_H 480

BBEPAPER bbep(EP75_800x480);
Preferences preferences;

unsigned long lastRefresh = 0;
const unsigned long REFRESH_INTERVAL = 20000;
const unsigned long FULL_REFRESH_INTERVAL = 600000;
unsigned long lastFullRefresh = 0;
unsigned int refreshCount = 0;
bool wifiConnected = false;
bool deviceRegistered = false;

String friendlyID = "";
String apiKey = "";

// Journey data from API
struct JourneyLeg {
    String icon;      // "walk", "tram", "train", "coffee"
    String title;     // "Walk to Tram Stop"
    String subtitle;  // "Smith St / Johnston St"
    int minutes;
};

JourneyLeg legs[4];
int legCount = 0;
String location = "Melbourne";
String currentTime = "00:00";
String weather = "Clear";
int temperature = 20;
String leaveBy = "--:--";
String arriveBy = "--:--";
int totalMinutes = 0;
String destination = "Work";
String coffeeDecision = "GO DIRECT";

// Tram/train data for simple view
struct Departure {
    int minutes;
    String destination;
};
Departure tramData[3];
Departure trainData[3];
int tramCount = 0;
int trainCount = 0;
String tramStop = "TRAMS";
String trainStop = "TRAINS";

void initDisplay();
void showBootScreen();
void connectWiFiSafe();
void registerDeviceSafe();
void fetchAndDisplaySafe();
void drawV11Dashboard();
void drawBoldText(int x, int y, const char* text);

void setup() {
    WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);

    Serial.begin(115200);
    delay(500);

    Serial.println("\n==============================");
    Serial.println("PTV-TRMNL v5.26 - V11 Dashboard");
    Serial.println("FONT_8x8 Only - Hardware Safe");
    Serial.println("==============================\n");

    preferences.begin("trmnl", false);

    friendlyID = preferences.getString("friendly_id", "");
    apiKey = preferences.getString("api_key", "");

    if (friendlyID.length() > 0 && apiKey.length() > 0) {
        Serial.print("✓ Loaded: ");
        Serial.println(friendlyID);
        deviceRegistered = true;
    }

    preferences.end();

    Serial.print("Free heap: ");
    Serial.println(ESP.getFreeHeap());

    initDisplay();
    showBootScreen();

    Serial.println("✓ Setup complete\n");
}

void loop() {
    if (!wifiConnected) {
        connectWiFiSafe();
        if (!wifiConnected) {
            delay(5000);
            return;
        }
        delay(2000);
        lastRefresh = millis();
        return;
    }

    if (!deviceRegistered) {
        registerDeviceSafe();
        if (!deviceRegistered) {
            delay(5000);
            return;
        }
        delay(2000);
        lastRefresh = millis();
        return;
    }

    unsigned long now = millis();

    if (now - lastRefresh >= REFRESH_INTERVAL) {
        lastRefresh = now;

        Serial.print("\n=== REFRESH Heap: ");
        Serial.print(ESP.getFreeHeap());
        Serial.println(" ===");

        if (WiFi.status() != WL_CONNECTED) {
            Serial.println("⚠ WiFi lost");
            wifiConnected = false;
            return;
        }

        fetchAndDisplaySafe();
    }

    delay(100);
}

void initDisplay() {
    Serial.println("→ bbep.initIO()...");
    bbep.initIO(EPD_DC_PIN, EPD_RST_PIN, EPD_BUSY_PIN, EPD_CS_PIN, EPD_MOSI_PIN, EPD_SCK_PIN, 8000000); bbep.setPanelType(EP75_800x480); pinMode(PIN_INTERRUPT, INPUT_PULLUP);
    delay(100);
    bbep.setRotation(0);
    bbep.fillScreen(BBEP_WHITE);
    bbep.setTextColor(BBEP_BLACK, BBEP_WHITE);
    bbep.setFont(FONT_8x8);  // CRITICAL: Only safe font!
    Serial.println("✓ Display ready");
}

void showBootScreen() {
    Serial.println("→ Boot screen...");
    bbep.fillScreen(BBEP_BLACK);
    bbep.setTextColor(BBEP_WHITE, BBEP_BLACK);
    bbep.setFont(FONT_8x8);
    
    bbep.setCursor(320, 200);
    bbep.print("PTV-TRMNL");
    
    bbep.setCursor(280, 240);
    bbep.print("V11 Journey Dashboard");
    
    bbep.setCursor(340, 300);
    bbep.print("v5.26");
    
    bbep.setCursor(300, 340);
    bbep.print("Connecting...");
    
    bbep.refresh(REFRESH_FULL, true);
    delay(500);
}

void connectWiFiSafe() {
    Serial.println("→ WiFi...");

    bbep.fillScreen(BBEP_WHITE);
    bbep.setTextColor(BBEP_BLACK, BBEP_WHITE);
    bbep.setFont(FONT_8x8);
    bbep.setCursor(300, 220);
    bbep.print("Connecting to WiFi...");
    bbep.refresh(REFRESH_FULL, true);

    WiFiManager wifiManager;
    wifiManager.setConfigPortalTimeout(180);

    if (wifiManager.autoConnect("PTV-TRMNL-Setup")) {
        wifiConnected = true;
        Serial.println("✓ WiFi connected");
    } else {
        Serial.println("⚠ WiFi failed");
        wifiConnected = false;
    }
}

void registerDeviceSafe() {
    Serial.println("→ Register...");

    WiFiClientSecure *client = new WiFiClientSecure();
    if (!client) return;

    client->setInsecure();
    HTTPClient http;
    String url = String(SERVER_URL) + "/api/setup";
    http.setTimeout(10000);

    if (!http.begin(*client, url)) {
        delete client;
        return;
    }

    String macAddress = WiFi.macAddress();
    http.addHeader("Content-Type", "application/json");

    String body = "{\"mac_address\":\"" + macAddress + "\"}";
    int httpCode = http.POST(body);

    if (httpCode == 200) {
        String response = http.getString();
        JsonDocument doc;
        if (!deserializeJson(doc, response)) {
            friendlyID = String(doc["friendly_id"] | "");
            apiKey = String(doc["api_key"] | "");

            if (friendlyID.length() > 0) {
                preferences.begin("trmnl", false);
                preferences.putString("friendly_id", friendlyID);
                preferences.putString("api_key", apiKey);
                preferences.end();

                deviceRegistered = true;
                Serial.print("✓ Registered: ");
                Serial.println(friendlyID);
            }
        }
    }

    http.end();
    delete client;
}

void fetchAndDisplaySafe() {
    Serial.println("→ Fetching...");

    String payload = "";
    {
        WiFiClientSecure *client = new WiFiClientSecure();
        if (!client) {
            Serial.println("⚠ No memory");
            return;
        }

        client->setInsecure();
        HTTPClient http;
        String url = String(SERVER_URL) + "/api/display";
        http.setTimeout(10000);

        if (!http.begin(*client, url)) {
            delete client;
            return;
        }

        http.addHeader("ID", friendlyID);
        http.addHeader("Access-Token", apiKey);
        http.addHeader("FW-Version", "5.26");

        int httpCode = http.GET();
        if (httpCode != 200) {
            Serial.print("⚠ HTTP ");
            Serial.println(httpCode);
            http.end();
            delete client;
            return;
        }

        payload = http.getString();
        http.end();
        delete client;
    }

    delay(300);
    yield();

    // Parse JSON
    {
        JsonDocument doc;
        DeserializationError error = deserializeJson(doc, payload);
        if (error) {
            Serial.print("⚠ Parse: ");
            Serial.println(error.c_str());
            return;
        }

        // Extract data
        currentTime = String(doc["current_time"] | "00:00");
        weather = String(doc["weather"] | "Clear");
        location = String(doc["location"] | "Melbourne");
        leaveBy = String(doc["leave_by"] | "--:--");
        arriveBy = String(doc["arrive_by"] | "--:--");
        coffeeDecision = String(doc["coffee_decision"] | "GO DIRECT");
        tramStop = String(doc["tram_stop"] | "TRAMS");
        trainStop = String(doc["train_stop"] | "TRAINS");
        destination = String(doc["work_address"] | "Work");

        // Parse trams
        JsonArray tramsArr = doc["trams"].as<JsonArray>();
        tramCount = 0;
        for (JsonObject t : tramsArr) {
            if (tramCount >= 3) break;
            tramData[tramCount].minutes = t["minutes"] | 0;
            tramData[tramCount].destination = String(t["destination"] | "City");
            tramCount++;
        }

        // Parse trains
        JsonArray trainsArr = doc["trains"].as<JsonArray>();
        trainCount = 0;
        for (JsonObject t : trainsArr) {
            if (trainCount >= 3) break;
            trainData[trainCount].minutes = t["minutes"] | 0;
            trainData[trainCount].destination = String(t["destination"] | "City");
            trainCount++;
        }

        // Build journey legs from data
        legCount = 0;
        
        // Leg 1: Walk to tram
        legs[legCount].icon = "walk";
        legs[legCount].title = "Walk to Tram Stop";
        legs[legCount].subtitle = tramStop;
        legs[legCount].minutes = 5;
        legCount++;
        
        // Leg 2: Tram
        if (tramCount > 0) {
            legs[legCount].icon = "tram";
            legs[legCount].title = "Tram to " + tramData[0].destination;
            legs[legCount].subtitle = "Departs in " + String(tramData[0].minutes) + " min";
            legs[legCount].minutes = tramData[0].minutes + 10;
            legCount++;
        }
        
        // Leg 3: Coffee (if applicable)
        if (coffeeDecision == "STOP FOR COFFEE") {
            legs[legCount].icon = "coffee";
            legs[legCount].title = "Coffee Stop";
            legs[legCount].subtitle = "Quick break";
            legs[legCount].minutes = 8;
            legCount++;
        }
        
        // Leg 4: Train or walk to work
        if (trainCount > 0) {
            legs[legCount].icon = "train";
            legs[legCount].title = "Train to " + trainData[0].destination;
            legs[legCount].subtitle = trainStop;
            legs[legCount].minutes = trainData[0].minutes + 5;
            legCount++;
        } else {
            legs[legCount].icon = "walk";
            legs[legCount].title = "Walk to Work";
            legs[legCount].subtitle = destination;
            legs[legCount].minutes = 6;
            legCount++;
        }

        // Calculate total
        totalMinutes = 0;
        for (int i = 0; i < legCount; i++) {
            totalMinutes += legs[i].minutes;
        }

        doc.clear();
    }

    payload = "";
    delay(200);
    yield();

    // Decide full vs partial refresh
    bool doFull = (refreshCount % 30 == 0) || (millis() - lastFullRefresh >= FULL_REFRESH_INTERVAL);
    if (doFull) {
        lastFullRefresh = millis();
    }

    drawV11Dashboard();
    refreshCount++;
}

// Draw text with simulated bold (double-strike)
void drawBoldText(int x, int y, const char* text) {
    bbep.setCursor(x, y);
    bbep.print(text);
    bbep.setCursor(x + 1, y);
    bbep.print(text);
}

void drawV11Dashboard() {
    Serial.println("→ Drawing V11 Dashboard...");
    
    bbep.fillScreen(BBEP_WHITE);
    bbep.setFont(FONT_8x8);
    bbep.setTextColor(BBEP_BLACK, BBEP_WHITE);

    // === HEADER ===
    // Location (top left)
    bbep.setCursor(20, 15);
    bbep.print(location.c_str());
    
    // Large time display (using bold text)
    char timeBuf[10];
    snprintf(timeBuf, sizeof(timeBuf), "%s", currentTime.c_str());
    drawBoldText(20, 40, timeBuf);
    drawBoldText(20, 55, timeBuf);  // Double height effect
    
    // Day and date (right of time)
    bbep.setCursor(150, 45);
    bbep.print("TUESDAY");  // TODO: Get from API
    bbep.setCursor(150, 60);
    bbep.print("28 January");
    
    // Weather box (top right)
    bbep.drawRect(640, 15, 140, 70, BBEP_BLACK);
    bbep.setCursor(660, 30);
    bbep.print(weather.c_str());
    bbep.setCursor(660, 50);
    bbep.print("NO UMBRELLA");

    // === STATUS BAR ===
    bbep.fillRect(0, 95, SCREEN_W, 25, BBEP_BLACK);
    bbep.setTextColor(BBEP_WHITE, BBEP_BLACK);
    
    char statusBuf[50];
    snprintf(statusBuf, sizeof(statusBuf), "LEAVE BY %s -> Arrive %s", leaveBy.c_str(), arriveBy.c_str());
    bbep.setCursor(20, 102);
    bbep.print(statusBuf);
    
    snprintf(statusBuf, sizeof(statusBuf), "%d min", totalMinutes);
    bbep.setCursor(700, 102);
    bbep.print(statusBuf);
    
    bbep.setTextColor(BBEP_BLACK, BBEP_WHITE);

    // === JOURNEY LEGS ===
    int legY = 135;
    int legHeight = 70;
    
    for (int i = 0; i < legCount && i < 4; i++) {
        int y = legY + (i * legHeight);
        
        // Leg box
        bbep.drawRect(20, y, 760, legHeight - 8, BBEP_BLACK);
        
        // Leg number circle (simulated)
        bbep.fillRect(35, y + 15, 30, 30, BBEP_BLACK);
        bbep.setTextColor(BBEP_WHITE, BBEP_BLACK);
        char numBuf[2];
        snprintf(numBuf, sizeof(numBuf), "%d", i + 1);
        bbep.setCursor(45, y + 25);
        bbep.print(numBuf);
        bbep.setTextColor(BBEP_BLACK, BBEP_WHITE);
        
        // Icon (text representation)
        bbep.setCursor(80, y + 20);
        if (legs[i].icon == "walk") bbep.print("[W]");
        else if (legs[i].icon == "tram") bbep.print("[T]");
        else if (legs[i].icon == "train") bbep.print("[R]");
        else if (legs[i].icon == "coffee") bbep.print("[C]");
        
        // Title and subtitle
        bbep.setCursor(130, y + 15);
        bbep.print(legs[i].title.c_str());
        bbep.setCursor(130, y + 35);
        bbep.print(legs[i].subtitle.c_str());
        
        // Minutes box
        bbep.fillRect(680, y + 10, 80, 40, BBEP_BLACK);
        bbep.setTextColor(BBEP_WHITE, BBEP_BLACK);
        char minBuf[10];
        snprintf(minBuf, sizeof(minBuf), "%d", legs[i].minutes);
        bbep.setCursor(705, y + 20);
        bbep.print(minBuf);
        bbep.setCursor(700, y + 35);
        bbep.print("MIN");
        bbep.setTextColor(BBEP_BLACK, BBEP_WHITE);
        
        // Arrow between legs
        if (i < legCount - 1) {
            bbep.setCursor(395, y + legHeight - 5);
            bbep.print("v");
        }
    }

    // === FOOTER ===
    bbep.fillRect(0, SCREEN_H - 30, SCREEN_W, 30, BBEP_BLACK);
    bbep.setTextColor(BBEP_WHITE, BBEP_BLACK);
    
    // Destination
    bbep.setCursor(20, SCREEN_H - 22);
    char destBuf[50];
    snprintf(destBuf, sizeof(destBuf), "%s", destination.c_str());
    bbep.print(destBuf);
    
    // Arrival time
    bbep.setCursor(600, SCREEN_H - 22);
    bbep.print("ARRIVE ");
    bbep.print(arriveBy.c_str());
    
    // Version (small, bottom right)
    bbep.setTextColor(BBEP_BLACK, BBEP_WHITE);
    bbep.setCursor(720, SCREEN_H - 45);
    bbep.print("v5.26");

    // Write to display
    Serial.println("→ Writing to e-paper...");
    bbep.refresh(REFRESH_FULL, true);
    Serial.println("✓ V11 Dashboard rendered");
}
